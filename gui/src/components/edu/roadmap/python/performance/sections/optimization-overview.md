---

# 📘 10.1 성능 최적화 개요

## ✅ 10.1.1 성능 최적화가 필요한 상황
1. **실행 속도 문제**
   - 대용량 데이터 처리
   - 복잡한 연산 작업
   - 실시간 처리 요구
2. **메모리 사용량 문제**
   - 메모리 누수
   - 대용량 데이터 로딩
   - 동시 접속자 처리
3. **시스템 리소스 활용**
   - CPU 사용률 최적화
   - I/O 작업 효율화
   - 네트워크 대역폭 활용

```python
# 성능 측정 예제
import time
import sys

def measure_performance(func):
    """함수의 실행 시간과 메모리 사용량을 측정하는 데코레이터"""
    def wrapper(*args, **kwargs):
        # 시작 시간과 메모리 사용량 기록
        start_time = time.time()
        start_memory = sys.getsizeof(func)
        
        # 함수 실행
        result = func(*args, **kwargs)
        
        # 종료 시간과 메모리 사용량 기록
        end_time = time.time()
        end_memory = sys.getsizeof(result)
        
        print(f"실행 시간: {end_time - start_time:.4f}초")
        print(f"메모리 사용량: {end_memory - start_memory:,} bytes")
        
        return result
    return wrapper
```

## ✅ 10.1.2 성능 최적화의 주요 원칙

1. **병목 현상 파악하기**
   - 코드의 어느 부분이 가장 많은 시간/자원을 소모하는지 찾기
   - 프로파일링 도구를 활용하여 정확한 측정
   - 추측이 아닌 데이터에 기반한 최적화 계획 수립

2. **최적화 우선순위 정하기**
   - 가장 큰 효과를 가져올 부분부터 최적화
   - 전체 실행 시간의 80%를 차지하는 20%의 코드 찾기 (80/20 법칙)
   - 사용자 경험에 직접적인 영향을 미치는 부분 우선 처리

3. **조기 최적화의 함정 주의**
   - 모든 코드를 처음부터 최적화하려 하지 않기
   - 먼저 코드를 작동하게 만들고, 필요한 경우에만 최적화
   - "조기 최적화는 모든 악의 근원이다" - 도널드 크누스

4. **최적화와 가독성의 균형**
   - 지나치게 최적화된 코드가 유지보수를 어렵게 할 수 있음
   - 코드의 가독성과 성능 사이의 적절한 균형 찾기
   - 복잡한 최적화는 문서화하기

--- 